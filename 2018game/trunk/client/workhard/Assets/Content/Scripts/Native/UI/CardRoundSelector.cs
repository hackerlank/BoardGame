using System;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;using DG.Tweening;[SLua.CustomLuaClass]public class CardRoundSelector : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler{    public enum Mode    {        Horizontal,        Vertical    }    public GameObject cardTemplate = null;    public Mode touchMode = Mode.Horizontal;    //是否循环    public bool isLoop;    public float radiusScale = 0.5f;    //偏移量    public float offset = 300;    //移动速度    public float speed = 0.01f;    //缩小比例    public float scale = 0.5f;    //显示图片的张数    public int showCardCount = 3;    // Control the position curve    public AnimationCurve positionCurve;    // Control the item's scale curve    public AnimationCurve scaleCurve;    //当前显示的Card id    public float current = 0;    private bool isDraging = false;    private List<GameObject> cards;    private System.Action<GameObject> _onTopChanged = null;    private Vector2 center = Vector2.zero;    private int curTop = -1;    private List<int> sortArray;    private void Awake()    {        Init();    }    public void Init()    {        if (cardTemplate == null)            return;        if (cards != null)            cards.Clear();        else            cards = new List<GameObject>();        sortArray = new List<int>();        center = cardTemplate.GetComponent<RectTransform>().anchoredPosition;        cardTemplate.SetActive(false);    }    /// <summary>
    /// Spawn card item
    /// </summary>
    /// <returns>item gameObject</returns>    public GameObject Spawn()    {        if (cardTemplate == null)            return null;        GameObject card = Instantiate(cardTemplate);        card.transform.SetParent(cardTemplate.transform.parent);        card.transform.localPosition = Vector3.zero;        card.transform.localScale = cardTemplate.transform.localScale;        card.transform.localRotation = cardTemplate.transform.rotation;        card.SetActive(true);        cards.Add(card);        return card;    }    public void SetOnTopChange(System.Action<GameObject> action)
    {
        _onTopChanged = action;
    }    /// <summary>    /// BeginDrag  event handle    /// </summary>    /// <param name="eventData">Event Data</param>    public void OnBeginDrag(PointerEventData eventData)    {        if (cards.Count == 0)            return;        isDraging = true;    }    /// <summary>    /// Drag event handle    /// </summary>    /// <param name="eventData">Event Data</param>    public void OnDrag(PointerEventData eventData)    {        if (cards.Count == 0)            return;        if(touchMode == Mode.Horizontal)            current -= eventData.delta.x * speed;        else if(touchMode == Mode.Vertical)            current -= eventData.delta.y * speed;        Refresh();    }    /// <summary>    /// EndDrag event handle    /// </summary>    /// <param name="eventData">Event Data</param>    public void OnEndDrag(PointerEventData eventData)    {        if (cards.Count == 0)            return;        float next = Mathf.Clamp(Mathf.Round(current), 0, cards.Count - 1);      
        DOTween.To(x => current = x, current, next, 0.2f)
                        .OnUpdate(Refresh)
                        .OnComplete(() =>
                        {
                            isDraging = false;
                        });
    }    /// <summary>
    /// Refresh card item position and scale
    /// </summary>    public void Refresh()    {        if (cards == null || cards.Count <= 0)            return;        if (false == isLoop)        {            current = Mathf.Clamp(current, 0, cards.Count - 1);            for (int i = 0; i < cards.Count; ++i)            {                RectTransform trans = cards[i].GetComponent<RectTransform>();                int showCard = (showCardCount - 1) / 2;                showCard = showCard >= 0 ? showCard : 0;                if (showCardCount > 0 && (i < current - showCard || i > current + showCard))                {                    trans.gameObject.SetActive(false);                }                else                {                    trans.gameObject.SetActive(true);                    if (i == current && i != curTop)                    {                        curTop = i;                        if (_onTopChanged != null) _onTopChanged.Invoke(cards[i]);                    }                    int idx = Mathf.RoundToInt(Mathf.Abs(i - current));                    trans.SetSiblingIndex(cards.Count - idx);                    if(touchMode == Mode.Horizontal)                        trans.anchoredPosition = center + new Vector2(offset * GetPosValue(i - current), 0);                              else if(touchMode == Mode.Vertical)                        trans.anchoredPosition = center + new Vector2(0, offset * GetPosValue(i - current));
                    trans.localScale = cardTemplate.transform.localScale * (scale + (1 - scale) * GetScaleValue(i - current));
                }            }        }        else        {            int cardCount = cards.Count;            if (current >= cardCount)                current = 0;            else if (current < 0)                current = cardCount ;            int centerCardIdx = cardCount / 2;            if (cardCount % 2 == 0)                centerCardIdx = cardCount / 2 - 1;            sortArray.Clear();            for (int i = 0; i < cardCount; i++)            {                if (i == current && i != curTop)                {                    curTop = i;                    if (_onTopChanged != null) _onTopChanged.Invoke(cards[i]);                }                float realOffset = centerCardIdx + i - current;                if (realOffset < 0)                    realOffset = realOffset + cardCount;                else if (realOffset >= cardCount)                    realOffset = realOffset - cardCount;                RectTransform trans = cards[i].GetComponent<RectTransform>();                int idx = cardCount - Mathf.RoundToInt(Mathf.Abs(realOffset - centerCardIdx));                if (sortArray.Contains(idx))                    idx = idx - 1;                sortArray.Add(idx);                trans.SetSiblingIndex(idx);

                if (touchMode == Mode.Horizontal)
                    trans.anchoredPosition = center + new Vector2(offset * GetPosValue(realOffset - centerCardIdx), 0);                else if (touchMode == Mode.Vertical)
                    trans.anchoredPosition = center + new Vector2(0, offset * GetPosValue(realOffset - centerCardIdx));
                trans.localScale = cardTemplate.transform.localScale * (scale + (1 - scale) * GetScaleValue(realOffset - centerCardIdx));            }        }    }    // Get the  value set the Item's position    private float GetPosValue(float sliderValue)    {        if (sliderValue > 1 || sliderValue < -1)            return sliderValue;        float evaluateValue = positionCurve.Evaluate(Mathf.Abs(sliderValue));        evaluateValue = evaluateValue * Mathf.Sign(sliderValue);               return evaluateValue;    }    // Get the evaluate value to set item's scale    private float GetScaleValue(float sliderValue)    {        float scaleValue =  1 - scaleCurve.Evaluate(Mathf.Abs(sliderValue));        return scaleValue;    }    /// <summary>    ///		Check if given card is on top.    /// </summary>    /// <param name="check">GameObject to check.</param>    /// <returns>True for this object is in top card.</returns>    public bool IsOnTop(GameObject check)    {        if (cards.Count <= 0)            return false;        int idx = Mathf.RoundToInt(current);        Transform top = cards[idx].transform;        return (check == top || check.transform.IsChildOf(top));    }    /// <summary>    ///		Bring card to top.    /// </summary>    /// <param name="obj">Card GameObject.</param>    public void BringUp(GameObject obj, System.Action onComplete = null)    {        for (int i = 0; i < cards.Count; ++i)        {            if (obj == cards[i])            {                DOTween                   .To(x => current = x, current, i, 0.2f)                   .OnUpdate(Refresh).OnComplete(() =>                   {                       if (onComplete != null)                           onComplete.Invoke();                   });                break;            }        }    }    private void Update()    {        if (isDraging)        {            return;        }            }    /// <summary>    ///		Clear all cards.    /// </summary>    public void Clear()    {        for (int i = 0; i < cards.Count; ++i) Destroy(cards[i]);        cards.Clear();        current = 0;        isDraging = false;        _onTopChanged = null;    }}